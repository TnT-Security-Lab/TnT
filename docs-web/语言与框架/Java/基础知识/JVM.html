<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-docs-web docs-doc-id-语言与框架/Java/基础知识/JVM">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.20">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="TnT安全知识库 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="TnT安全知识库 Atom Feed"><title data-rh="true">JVM | TnT安全知识库</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://TnT-Security-Lab.github.io/docs-web/语言与框架/Java/基础知识/JVM"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="keywords" content="Gungnir, urdr-gungnir, TnT, TnT-security-lab, blog, javascript, typescript, python ,node, react, vue, web, 前端, 后端"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-docs-web-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-docs-web-current"><meta data-rh="true" property="og:title" content="JVM | TnT安全知识库"><meta data-rh="true" name="description" content="我们平常已经写过很多Java的代码，但当问起这些代码是如何运行的时候，可能会一问三不知。想弄明白这个问题就需要了解一下JVM。JVM（Java Virtual Machine），也称Java虚拟机，主要任务是负责**装载字节码到其内部**，不过字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。本文会按下图讲解JVM所含的内容。"><meta data-rh="true" property="og:description" content="我们平常已经写过很多Java的代码，但当问起这些代码是如何运行的时候，可能会一问三不知。想弄明白这个问题就需要了解一下JVM。JVM（Java Virtual Machine），也称Java虚拟机，主要任务是负责**装载字节码到其内部**，不过字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。本文会按下图讲解JVM所含的内容。"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://TnT-Security-Lab.github.io/docs-web/语言与框架/Java/基础知识/JVM"><link data-rh="true" rel="alternate" href="https://TnT-Security-Lab.github.io/docs-web/语言与框架/Java/基础知识/JVM" hreflang="en"><link data-rh="true" rel="alternate" href="https://TnT-Security-Lab.github.io/docs-web/语言与框架/Java/基础知识/JVM" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.10714433.css">
<link rel="preload" href="/assets/js/runtime~main.906e371d.js" as="script">
<link rel="preload" href="/assets/js/main.16b6c330.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="TnT" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="TnT" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title text--truncate">TnT</b></a><a class="navbar__item navbar__link" href="/docs/intro">投稿教程</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs-web/Intro">WEB安全</a><a class="navbar__item navbar__link" href="/docs-binary/Intro">二进制安全</a><a class="navbar__item navbar__link" href="/docs-ctf/Intro">CTF</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/blog">关于我们</a><a href="https://github.com/TnT-Security-Lab" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_dLyj"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_mKqt"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><div class="docPage_ualW"><aside class="theme-doc-sidebar-container docSidebarContainer_UQUJ"><div class="sidebar_RiAD"><nav class="menu thin-scrollbar menu_izAj"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs-web/11">11</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs-web/intro">Web安全模块</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs-web/常见漏洞类型/sql注入">常见漏洞类型</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs-web/语言与框架/Java/基础知识/JVM">语言与框架</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs-web/语言与框架/Java/基础知识/JVM">Java</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs-web/语言与框架/Java/基础知识/JVM">基础知识</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs-web/语言与框架/Java/基础知识/JVM">JVM</a></li></ul></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_uL0j"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Xlws" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_kU5B"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">语言与框架</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">基础知识</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">JVM</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_bZGK theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_l22C">On this page</button></div><div class="theme-doc-markdown markdown"><h1>JVM</h1><p><img loading="lazy" alt="总图" src="/assets/images/总图-4a736ec5c8462c45370c311f7c223139.png" width="851" height="690" class="img_E7b_"></p><p>​		<code>虚拟机</code>是一个相对于<code>物理机</code>的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="jvm发展历程">JVM发展历程<a class="hash-link" href="#jvm发展历程" title="Direct link to heading">​</a></h2><h4 class="anchor anchorWithStickyNavbar_mojV" id="sun-classic-vm">Sun Classic VM<a class="hash-link" href="#sun-classic-vm" title="Direct link to heading">​</a></h4><p>​		早在1996年Java1.0版本的时候，<code>Sun</code>公司发布了一款名为<code>sun classic VM</code>的Java虚拟机，它同时也是<strong>世界上第一款商用Java虚拟机</strong>，JDK1.4时完全被淘汰。这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。解释器和编译器不能配合工作，一旦使用<code>JIT编译器</code>，JIT就会接管虚拟机的执行系统。解释器就不再工作。现在<code>Hotspot</code>内置了此虚拟机。</p><ul><li><p>即时编译器会把热点代码的本地机器指令缓存起来，以后使用热点代码时，不需要重复解析，效率较高。</p></li><li><p>将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，会导致启动时卡顿。</p></li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="exact-vm">Exact VM<a class="hash-link" href="#exact-vm" title="Direct link to heading">​</a></h4><p>​		为了解决上一个虚拟机问题，jdk1.2时，<code>Sun</code>提供了此虚拟机。该虚拟机号称Exact Memory Management（准确式内存管理），具有热点探测的功能，采用编译器与解释器混合的工作模式。遗憾的是，只能在<code>Solaris平台</code>使用，其他平台上还是<code>Classic VM</code>，不久被<code>Hotspot</code>虚拟机替换。</p><ul><li><p>准确式内存管理：虚拟机可以知道内存中某个位置的数据具体是什么类型，这也是与<code>Classic VM</code>最大的不同。</p></li><li><p>热点探测：寻找出热点代码进行缓存。</p></li></ul><p>接下来是<strong>三大商用虚拟机</strong>。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="hotspot-vm">Hotspot VM<a class="hash-link" href="#hotspot-vm" title="Direct link to heading">​</a></h4><ul><li>最初由一家名为<code>Longview Technologies</code>的小公司设计。1997年，此公司被<code>Sun</code>收购；2009年，<code>Sun公司</code>被<code>甲骨文</code>收购。JDK1.3时，<code>Hotspot VM</code>成为默认虚拟机。</li><li>目前<code>Hotspot</code>占有绝对的市场地位<ul><li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK1.8中，默认的虚拟机都是<code>Hotspot</code>。</li><li><code>Sun/oracle JDK</code>和<code>openJDK</code>的默认虚拟机都是<code>Hotspot</code>。</li><li>其他两个商用虚拟机均没有方法区的概念。</li></ul></li><li>从服务器、桌面到移动端、嵌入式都有应用</li><li>名称中的<code>Hotspot</code>指的就是它的热点代码探测技术<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换。</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="jrockit">JRockit<a class="hash-link" href="#jrockit" title="Direct link to heading">​</a></h4><ul><li>专注于服务器端应用<ul><li>它不关注程序启动速度，因此<code>JRockit</code>内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li></ul></li><li>大量的行业基准测试显示，<code>JRockit JVM</code>是世界上最快的JVM<ul><li>使用<code>JRockit</code>产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li></ul></li><li>优势：全面的Java运行时解决方案组合<ul><li><code>JRockit</code>面向延迟敏感型应用的解决方案<code>JRockit Real Time</code>提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要。</li><li><code>Mission Control</code>服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li>2008年，<code>JRockit</code>被<code>Oracle</code>收购。<code>Oracle</code>也表达了整合两大优秀虚拟机的工作，大致在JDK1.8中完成。整合的方式是在<code>Hotspot</code>的基础上，移植<code>JRockit</code>的优秀特性。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="ibm的j9">IBM的J9<a class="hash-link" href="#ibm的j9" title="Direct link to heading">​</a></h4><p>​		全称：<code>IBM Technology for Java Virtual Machine</code>，简称<code>IT4J</code>，内部代号：<code>J9</code>。市场定位与<code>Hotspot</code>接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于<code>IBM</code>的各种Java产品。目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机，当然，是指在IBM自己的系统上。2017年左右，<code>IBM</code>发布了<code>开源J9VM</code>，命名为<code>openJ9</code>，交给Eclipse基金会管理，也称为<code>Eclipse OpenJ9</code>。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="类加载子系统">类加载子系统<a class="hash-link" href="#类加载子系统" title="Direct link to heading">​</a></h2><p>JVM的工作始于Class文件，第一个经过的就是<strong>类加载器子系统</strong>（Class Loader SubSystem），下面我们了解一下类加载子系统。</p><p><strong>类加载子系统作用</strong></p><ul><li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。</li><li>Class Loader（类加载器）只负责将class文件从硬盘中加载到JVM中，至于它是否可以运行，则由执行引擎决定。</li><li><strong>加载的类信息存放于方法区</strong>，被称为<code>DNA元数据模板</code>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="类的生命周期">类的生命周期<a class="hash-link" href="#类的生命周期" title="Direct link to heading">​</a></h3><p>首先举个例子。</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloWorld {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;HelloWorld&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这应该是Java的入门代码，那我们看一下它的加载过程：</p><ul><li>先加载main方法所在类HelloWorld。</li><li>接下来由ClassLoader进行加载。开发人员既可以使用JVM提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</li><li>加载成功，即可继续连接初始化等操作，运行main方法，输出HelloWorld，执行垃圾回收。</li><li>加载失败，抛出异常，结束生命周期。</li></ul><p>​		下面是类的生命周期，其中加载器的执行流程，包括加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img loading="lazy" alt="类的生命周期" src="/assets/images/类的生命周期-95947c5a7b77af94f04061612f74436d.png" width="831" height="252" class="img_E7b_"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="加载">加载<a class="hash-link" href="#加载" title="Direct link to heading">​</a></h4><p>这里指的加载并不是类的加载，而是类加载的第一步，准确来说，这一步应称为装载。</p><p>加载阶段需要完成以下三件事情：</p><ul><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li></ul><p>注：类加载器并不需要等到某个类被<strong>首次主动使用</strong>时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError)，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><p><strong>加载class文件的方式</strong></p><ul><li>从本地系统中直接加载。</li><li>通过网络获取，典型场景：Web Applet。</li><li>从zip压缩包中读取，成为日后jar、war格式的基础。</li><li>运行时计算生成，使用最多的是：动态代理技术。</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见。</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="连接">连接<a class="hash-link" href="#连接" title="Direct link to heading">​</a></h4><p>由图可知，连接阶段又分为三部分，Verify（验证），Prepare（准备），Reslove（解析）。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="验证">验证<a class="hash-link" href="#验证" title="Direct link to heading">​</a></h5><ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。<ul><li>文件格式验证: 验证字节流是否符合Class文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证: 对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li><li>字节码验证: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证: 确保解析动作能正确执行。</li></ul></li></ul><p>注：验证阶段很重要，但也不是必须的，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="准备">准备<a class="hash-link" href="#准备" title="Direct link to heading">​</a></h5><p>此阶段为类变量（static变量）分配内存并且设置该类变量的默认初始值，即<code>null</code>，<code>0</code>，<code>0.0</code>，<code>&#x27;\0&#x27;</code>，<code>false</code>等。</p><ul><li>同时被final和static修饰的变量在编译的时候就会分配好了默认值，准备阶段会显式初始化。</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到堆中。</li><li>对于引用数据类型来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ul><h5 class="anchor anchorWithStickyNavbar_mojV" id="解析">解析<a class="hash-link" href="#解析" title="Direct link to heading">​</a></h5><p>​		解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，对应常量池中的<code>CONSTANT Class info</code>、<code>CONSTANT Fieldref info</code>、<code>CONSTANT Methodref info</code>等。</p><ul><li>符号引用就是一组符号来描述所引用的目标，可以是任何字面量。</li><li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="初始化">初始化<a class="hash-link" href="#初始化" title="Direct link to heading">​</a></h4><p>此阶段为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p><p>在Java中对类变量进行初始值设定有两种方式：</p><ul><li><p>声明类变量是指定初始值</p></li><li><p>使用静态代码块为类变量指定初始值</p><p><strong>JVM初始化步骤</strong></p></li><li><p>假如这个类还没有被加载和连接，则程序先加载并连接该类。</p></li><li><p>假如该类的直接父类还没有被初始化，则先初始化其直接父类。</p></li><li><p>假如类中有初始化语句，则系统依次执行这些初始化语句。</p></li></ul><p><strong>类的初始化时机</strong></p><ul><li><p>创建类的实例，即new一个对象时。</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值。</p></li><li><p>调用类的静态方法。</p></li><li><p>反射（比如：Class.forName(“com.company.Test”)）。</p></li><li><p>初始化某类的子类，其父类也会被初始化。</p></li><li><p>Java虚拟机启动时被标明为启动类的类，直接使用java.exe命令来运行。</p></li><li><p>JDK1.7开始提供的动态语言支持：<code>java.lang.invoke.MethodHandle</code>实例的解析结果<code>REF_getStatic</code>、<code>REF putStatic</code>、<code>REF_invokeStatic</code>句柄对应的类没有初始化，则初始化</p></li></ul><p><strong>以下情况不会触发初始化</strong></p><ul><li>通过数组定义来引用类，不会触发此类的初始化</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化：</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="使用">使用<a class="hash-link" href="#使用" title="Direct link to heading">​</a></h4><p>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="卸载">卸载<a class="hash-link" href="#卸载" title="Direct link to heading">​</a></h4><p>此阶段会执行垃圾回收机制。</p><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了<code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="类加载器">类加载器<a class="hash-link" href="#类加载器" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="类加载器分类" src="/assets/images/类加载器分类-558b2793167103ea6ec07611ef69205a.png" width="777" height="491" class="img_E7b_"></p><p>注：这里四者的关系是包含，不是上层下层，也不是子父类的继承关系。</p><ul><li><p>站在JVM的角度，类加载器分为启动类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p></li><li><p>站在开发人员的角度，类加载器分为启动类加载器（Bootstrap ClassLoader），扩展类加载器（Extension ClassLoader），应用程序类加载器（Application ClassLoader），也称系统类加载器（System Class Loader）。</p><ul><li><p>启动类加载器（Bootstrap ClassLoader）：这个类加载器是 Java 虚拟机实现的一部分，不是 Java 语言实现的，一般是 C++ 实现的，它负责加载 Java 的基础类，主要是 <code>JAVA_HOME/lib/rt.jar</code>，当然也包括<code>resources.jar</code>或<code>sun.boot.class.path</code>路径下的内容。</p><ul><li><p>并不继承自java.lang.ClassLoader，没有父加载器。</p></li><li><p>加载扩展类和应用程序类加载器，并作为他们的父类加载器。</p></li><li><p>出于安全考虑，只加载包名为java、javax、sun等开头的类。</p></li></ul></li><li><p>扩展类加载器（Extension ClassLoader）：负责加载 Java 的一些扩展类，一般是 <code>JAVA_HOME/lib/ext</code>目录中的 jar 包。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p></li><li><p>应用程序类加载器（Application ClassLoader）：负责加载应用程序的类，包括自己写的和引入的第三方类库，即所有在类路径中指定的类。</p></li></ul></li></ul><p>应用程序都是由这三种类加载器互相配合进行加载的，当然，如果需要，我们也可以加入自定义的类加载器。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="jvm类加载机制">JVM类加载机制<a class="hash-link" href="#jvm类加载机制" title="Direct link to heading">​</a></h3><ul><li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li><li>父类委托：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</li><li>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</li><li>双亲委派机制：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="双亲委派机制">双亲委派机制<a class="hash-link" href="#双亲委派机制" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="双亲委派机制" src="/assets/images/双亲委派机制-51c06225710e107a1cb8929e1409e091.png" width="835" height="424" class="img_E7b_"></p><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常。</li></ul><p>如果你看上面这段话有些蒙，不妨看下面这个<strong>例子</strong>。</p><p>创建一个<code>java.lang.String</code>类（当然在正常写程序时我们不会做这种事，也不允许这么做），很明显这和Java原有的String类冲突，那么我们new一个String看一下调用的是哪一个String吧。</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">package java.lang;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;这是自定义的String类&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">public class TTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String s = new String();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>结果并未输出<code>这是自定义的String类</code>这句话，说明new的String是Java原有的String类。</p><p><img loading="lazy" alt="举例一" src="data:image/png;base64,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" width="648" height="200" class="img_E7b_"></p><p>当代码运行到new String()时即需要加载String类，那么按照应用程序加载器，扩展类加载器，启动类加载器的顺序向上委托，先由启动类加载器判断自己是否可以加载，如果不能则继续向下判断。String类位于java.lang包中，在上文提到java开头的类会由启动类加载器加载，所以此处加载的String类为Java自带的String，而非我们自定义的String类。</p><p>而当我们试图在String种调用main方法时</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;String的main方法被调用&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>则会抛出异常</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public static void main(String[] args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这也是因为加载的String类并非我们自定义的String类，而Java自带的String中并无main方法。这样可以保证对java核心源代码的保护，也就是沙箱安全机制。</p><p>通过上面这个例子得出双亲委派机制的优势：</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="运行时数据区">运行时数据区<a class="hash-link" href="#运行时数据区" title="Direct link to heading">​</a></h2><p>类加载完成后就需要执行引擎来进行执行，执行引擎执行过程中就用到运行时数据区，接下来讲解运行时数据区。</p><p>下图是运行时数据区包含的若干程序，下面会一一进行介绍。</p><p><img loading="lazy" alt="运行时数据区" src="/assets/images/运行时数据区-53a28182eecd8530ccb0f5321b295948.png" width="1205" height="538" class="img_E7b_"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="程序计数器">程序计数器<a class="hash-link" href="#程序计数器" title="Direct link to heading">​</a></h3><p>​		程序计数器（Program Counter Register），也称PC寄存器，是一块很小的内存空间，几乎可以忽略不记，也是运行速度最快的存储区域。用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">Oracle官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何<code>OutofMemoryError</code>情况的区域。</li></ul><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></p><p>​		因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><strong>PC寄存器为什么会被设定为线程私有的？</strong></p><p>​		多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="虚拟机栈">虚拟机栈<a class="hash-link" href="#虚拟机栈" title="Direct link to heading">​</a></h3><p>​		Java 虚拟机栈(Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p><ul><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ul><p><strong>虚拟机栈的作用</strong></p><p>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</p><p><strong>虚拟机栈的特点</strong></p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行，伴随着<strong>进栈</strong></li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li>栈不需要GC（Garbage Collection，垃圾收集器），但是可能存在OOM（OutofMemoryError）。</li></ul><p><strong>栈中可能出现的异常</strong>：</p><p>Java 虚拟机规范允许 <strong>Java虚拟机栈的大小是动态的或者是固定不变的</strong></p><ul><li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li></ul><p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><p>官方提供的参考工具，可查一些参数和操作：</p><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BGBCIEFC</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>栈运行原理</strong></p><ul><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）。</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧。</li><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java 方法有两种返回函数的方式，一种是<strong>正常的函数返回</strong>，使用 return 指令，另一种是<strong>抛出异常</strong>，不管用哪种方式，都会导致栈帧被弹出。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="栈帧">栈帧<a class="hash-link" href="#栈帧" title="Direct link to heading">​</a></h4><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息，每一个方法对应一个栈帧。</p><p><img loading="lazy" alt="栈帧" src="/assets/images/栈帧-4fe5ca3fee7d708ad50d9d22f11c189d.png" width="970" height="474" class="img_E7b_"></p><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）（或表达式栈）</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p>注：栈帧的大小主要由局部变量表和操作数栈决定的。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="本地方法栈">本地方法栈<a class="hash-link" href="#本地方法栈" title="Direct link to heading">​</a></h3><p><strong>本地方法</strong></p><p>简单来讲，native方法就是 Java 调用非 Java 代码的接口。本地方法出现的原因有以下几点：</p><ul><li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li><li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 JRE 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li><li>Sun&#x27;s Java：Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。JRE大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是C实现的，并被植入 JVM 内部。</li></ul><p>接下来介绍<strong>本地方法栈</strong>（Native Method Stack）</p><ul><li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</li><li>本地方法栈是使用 C 语言实现的，也是线程私有的，并且允许线程固定或者可动态扩展的内存大小。具体做法是在本地方法栈中登记 native 方法，在执行引擎执行时加载本地方法库。</li><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，和虚拟机拥有同样的权限。本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存，这是因为操作系统是由c和汇编编写，所以可以直接调用本地处理器。</li></ul><p>注：并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="堆区">堆区<a class="hash-link" href="#堆区" title="Direct link to heading">​</a></h3><p>堆（Heap）是Java内存管理的核心区域。</p><ul><li>一个进程只存在一个JVM实例，也只存在一个堆区。</li><li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大的一块内存空间，大小是可以调节的。</li><li>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li>所有的线程共享Java堆，不过可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</li><li><strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。</li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除，即触发GC时，才进行回收。<ul><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the world。</li><li>堆是GC执行垃圾回收的重点区域。</li></ul></li></ul><p>​		主流虚拟机都是可扩展的，可以通过 <code>-Xmx</code>（起始内存） 和 <code>-Xms</code>（最大内存） 控制，如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能。</p><p>为了进行高效的垃圾回收，<strong>虚拟机把堆内存逻辑上划分成三块区域</strong></p><ul><li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代。<ul><li>新生代又可划分为<code>Eden空间</code>、<code>Survivor0空间</code>和<code>Survivor1空间</code>（有时也叫做from区、to区）。</li><li>Eden空间和另外两个survivor空间默认所占的比例是8 : 1 : 1，当然开发人员可以通过选项<code>-XX:SurvivorRatio</code>调整这个空间比例。</li><li>几乎所有的Java对象都是在Eden区被new出来的，前面提到的TLAB也是在Eden空间上划分的。</li></ul></li><li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大。</li><li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存。<ul><li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li><li>JDK1.7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，JDK1.8 之后，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数。</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="方法区">方法区<a class="hash-link" href="#方法区" title="Direct link to heading">​</a></h3><p>​		方法区（Method Area），也称为非堆区，与 Java 堆一样，是所有线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p><strong>类型信息</strong></p><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><p><strong>域信息</strong></p><ul><li>JVM 必须在方法区中保存类型的所有域（成员变量）的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li></ul><p><strong>方法信息</strong></p><p>JVM 必须保存所有方法的</p><ul><li>方法名称</li><li>方法的返回类型</li><li>方法参数的数量和类型</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。</li></ul></li></ul><p><strong>从线程共享与否可将运行时数据区重新分类</strong></p><p><img loading="lazy" alt="运行时数据区2" src="/assets/images/运行时数据区2-0832e1c8305d1c4e2dfdd68eface2397.png" width="1054" height="504" class="img_E7b_"></p><ul><li>多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code>（JDK1.8之后）。<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="运行时常量池">运行时常量池<a class="hash-link" href="#运行时常量池" title="Direct link to heading">​</a></h4><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池（Runtime Constant Pool）。</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的符号引用和各种字面量，包括要执行的类名、方法名、参数类型、字面量等类型，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组一样，是通过索引访问的。</li><li>运行时常量池中包含各种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li><li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 <code>OutOfMemoryError</code> 异常。</li></ul><p><strong>堆栈方法区三者的关系</strong></p><p><img loading="lazy" alt="三者关系" src="/assets/images/三者关系-9718743301cd72ec1353b7d71f4d5563.png" width="988" height="514" class="img_E7b_"></p><p>比如我们new一个对象<code>Person p = new Person();</code>，那么p将存放在栈上，指向放在堆上的对象，Person.class放在方法区。在 person 对象中，还有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="执行引擎">执行引擎<a class="hash-link" href="#执行引擎" title="Direct link to heading">​</a></h2><p>​		执行引擎（Execution Engine）是Java虚拟机核心的组成部分之一，其任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</p><p>方法在执行的过程中，执行引擎可以通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</p><p>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：</p><ul><li>输入的是字节码二进制流</li><li>处理过程是字节码解析执行、即时编译的等效过程</li><li>输出的是执行过程</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="垃圾回收">垃圾回收<a class="hash-link" href="#垃圾回收" title="Direct link to heading">​</a></h2><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">官网：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="标记阶段">标记阶段<a class="hash-link" href="#标记阶段" title="Direct link to heading">​</a></h3><p>​		垃圾标记阶段主要是为了<strong>判断对象是否存活</strong>，只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放其所占用的内存空间。判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p><ul><li>JVM如何标记一个死亡对象？</li></ul><p>​		简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="引用计数算法">引用计数算法<a class="hash-link" href="#引用计数算法" title="Direct link to heading">​</a></h4><p>​		引用计数算法（Reference Counting）会对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><ul><li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li><li>缺点：<ul><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li>引用计数算法<strong>无法处理循环引用</strong>，所以在Java的垃圾回收器中没有使用这类算法。</li></ul></li></ul><p><strong>循环引用</strong></p><p><img loading="lazy" alt="循环引用" src="/assets/images/循环引用-94f945986df27a7c999369c044730ea2.png" width="941" height="473" class="img_E7b_"></p><p>如图，当p的指针指向null时，内部的引用形成一个循环，使得计数器不是0，无法被回收，从而造成内存泄漏，这就是循环引用。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="可达性分析算法">可达性分析算法<a class="hash-link" href="#可达性分析算法" title="Direct link to heading">​</a></h4><p>​		可达性分析算法，也称根搜索算法、追踪性垃圾收集（Tracing Garbage Collection），具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。通过 <code>GC Roots</code> 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p><p><img loading="lazy" alt="可达性分析算法" src="/assets/images/可达性分析算法-7d7ce5a18f0a2319e3e2fb316ae04893.png" width="804" height="543" class="img_E7b_"></p><p><strong>实现思路</strong></p><ul><li>可达性分析算法是以根对象集合（<code>GC Roots</code>）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong><ul><li><code>GC Roots</code> ： 一组必须活跃的引用。</li></ul></li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li></ul><p><strong>Java 虚拟机使用该算法来判断对象是否可被回收</strong>，那么 <code>GC Roots</code> 可以是哪些元素？</p><ul><li>虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等。</li><li>本地方法栈内JNI（本地方法）引用的对象。</li><li>方法区中类静态属性引用的对象。比如：Java类的引用类型静态变量。</li><li>方法区中常量引用的对象。比如：字符串常量池（StringTable）里的引用。</li><li>所有被同步锁<code>synchronized</code>持有的对象。</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地代码缓存等。</li></ul><p>后两种不太常见，了解就行。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="清除阶段">清除阶段<a class="hash-link" href="#清除阶段" title="Direct link to heading">​</a></h3><p>​		当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是标记-清除算法（Mark-Sweep），复制算法（Copying）和标记-压缩算法（Mark-Compact）。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="标记-清除算法">标记-清除算法<a class="hash-link" href="#标记-清除算法" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="标记清除算法" src="/assets/images/标记清除算法-66d406cbeb73f1dc0040e0a2783ce74b.png" width="675" height="221" class="img_E7b_"></p><p>​		当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p><ul><li>标记：<code>Collector</code>从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的<code>Header</code>中记录为可达对象。<ul><li>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li></ul></li><li>清除：<code>Collector</code>对堆内存从头到尾进行线性的遍历，如果发现某个对象在其<code>Header</code>中没有标记为可达对象，则将其回收。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="复制算法">复制算法<a class="hash-link" href="#复制算法" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="复制算法" src="/assets/images/复制算法-db4dc331f4a3deb804618c99fa868cdd.png" width="685" height="246" class="img_E7b_"></p><p>​		将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。新生代里面就用到了复制算法，将<code>Eden区</code>和<code>S0区</code>存活对象整体复制到<code>S1区</code>。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="标记-压缩算法">标记-压缩算法<a class="hash-link" href="#标记-压缩算法" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="标记压缩算法" src="/assets/images/标记压缩算法-1ed3645bf5bd8fa1fc9b7c42d493f205.png" width="681" height="227" class="img_E7b_"></p><p>​		复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，<strong>复制的成本也将很高</strong>。因此，基于老年代垃圾回收的特性，采用标记-压缩算法。</p><ul><li>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象。</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</li></ul><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><p><strong>三者对比</strong></p><table><thead><tr><th align="center"></th><th align="center">标记-清除算法</th><th align="center">标记-整理算法</th><th align="center">复制算法</th></tr></thead><tbody><tr><td align="center"><strong>速率</strong></td><td align="center">中等</td><td align="center">最慢</td><td align="center">最快</td></tr><tr><td align="center"><strong>空间开销</strong></td><td align="center">少（但会堆积碎片）</td><td align="center">少</td><td align="center">通常需要活对象的2倍空间</td></tr><tr><td align="center"><strong>移动对象</strong></td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_mojV" id="分代收集算法">分代收集算法<a class="hash-link" href="#分代收集算法" title="Direct link to heading">​</a></h4><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点，分代收集算法应运而生。</p><p>分代收集算法，基于<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:</p><ul><li>比如<code>Http</code>请求中的<code>Session</code>对象、线程、<code>Socket</code>连接，这类对象跟业务直接挂钩，因此生命周期比较长。</li><li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul><p><strong>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</strong>。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="finalize">finalize()<a class="hash-link" href="#finalize" title="Direct link to heading">​</a></h4><p><code>finalize()</code> 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 <code>try-finally</code> 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>当一个对象可被回收时，如果需要执行该对象的 <code>finalize()</code> 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 <code>finalize() </code>方法自救，后面回收时不会调用 <code>finalize()</code> 方法。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="引用类型">引用类型<a class="hash-link" href="#引用类型" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="强引用">强引用<a class="hash-link" href="#强引用" title="Direct link to heading">​</a></h4><ul><li>在Java程序中，最常见的引用类型是强引用（Strong Reference），<strong>是默认的引用类型</strong>。</li><li>当使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</li><li><strong>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></li><li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将其赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</li><li>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="软引用">软引用<a class="hash-link" href="#软引用" title="Direct link to heading">​</a></h4><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p><ul><li>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。<ul><li>注意，这里的第一次回收是不可达的对象。</li></ul></li><li>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li><li>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</li><li>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</li></ul><p>总结：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象。</p><p>在JDK1.2版之后提供了<code>SoftReference</code>类来实现软引用：</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">// 获得唯一的软引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object obj = new Object();// 声明强引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SoftReference&lt;Object&gt; sf = new SoftReference&lt;&gt;(obj);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">obj = null; //销毁强引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 从软引用中重新获得强引用对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(userSoftRef.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 垃圾回收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.gc();</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="弱引用">弱引用<a class="hash-link" href="#弱引用" title="Direct link to heading">​</a></h4><p><strong>弱引用（Weak Reference）:发现即回收</strong></p><ul><li>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</strong>。</li><li>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li><li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</li><li>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</li></ul><p>在JDK1.2版之后提供了<code>WeakReference</code>类来实现弱引用：</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">// 获得唯一的弱引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 声明强引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object obj = new Object();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WeakReference&lt;Object&gt; sf = new WeakReference&lt;&gt;(obj);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">obj = null; //销毁强引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//从弱引用中重新获取对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(userWeakRef.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 垃圾回收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.gc();</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="虚引用">虚引用<a class="hash-link" href="#虚引用" title="Direct link to heading">​</a></h4><p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p><ul><li>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</li><li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li><li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的<code>get()</code>方法取得对象时，总是null 。<strong>即通过虚引用无法获取到我们的数据</strong>。</li><li><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></li><li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li><li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li></ul><p>在JDK1.2版之后提供了<code>PhantomReference</code>类来实现虚引用。</p><div class="language-java codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-java codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">// 获得唯一的虚引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 声明强引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object obj = new Object();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 声明引用队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ReferenceQueue phantomQueue = new ReferenceQueue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 声明虚引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PhantomReference&lt;Object&gt; sf = new PhantomReference&lt;&gt;(obj, phantomQueue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">obj = null; // 销毁强引用</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="垃圾收集器">垃圾收集器<a class="hash-link" href="#垃圾收集器" title="Direct link to heading">​</a></h3><p>这是七款经典的垃圾回收器，下面会一一介绍。</p><p><img loading="lazy" alt="垃圾收集器" src="/assets/images/垃圾收集器-c67ac9a74b257b78c263193233a6bc0e.png" width="887" height="471" class="img_E7b_"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="serial-收集器">Serial 收集器<a class="hash-link" href="#serial-收集器" title="Direct link to heading">​</a></h4><p><strong>Serial 收集器：串行回收</strong></p><p><img loading="lazy" alt="Serial" src="/assets/images/Serial-205ae0deb09d40c0bb61ed425531f855.png" width="1081" height="313" class="img_E7b_"></p><p><code>Serial 收集器</code>是一个单线程的收集器，它只会使用一个CPU或一条收集线程去完成垃圾回收。它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。</p><ul><li><code>Serial 收集器</code>是<code>Hotspot</code>中Client模式下的默认新生代垃圾收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。<code>Serial 收集器</code>收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</li><li><code>Serial 收集器</code>采用复制算法、串行回收和<code>Stop-the-World</code>机制的方式执行内存回收。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="serial-old-收集器">Serial Old 收集器<a class="hash-link" href="#serial-old-收集器" title="Direct link to heading">​</a></h4><ul><li>除了年轻代之外，<code>Serial收集器</code>还提供用于执行老年代垃圾收集的<code>Serial Old收集器</code>。<code>Serial old收集器</code>同样也采用了串行回收和<code>Stop the World</code>机制，只不过内存回收算法使用的是标记-压缩算法。</li><li><code>Serial Old</code>是运行在Client模式下默认的老年代的垃圾回收器，<code>Serial Old</code>在Server模式下主要有两个用途：<ul><li>与新生代的<code>Parallel Scavenge</code>配合使用</li><li>作为老年代<code>CMS收集器</code>的后备垃圾收集方案</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="parnew-收集器">ParNew 收集器<a class="hash-link" href="#parnew-收集器" title="Direct link to heading">​</a></h4><p><strong>ParNew 收集器：并行回收</strong></p><p><img loading="lazy" alt="ParNew" src="/assets/images/ParNew-b2f75f5063126577be1919af19fccbd2.png" width="1223" height="366" class="img_E7b_"></p><p>如果说<code>Serial GC</code>是年轻代中的单线程垃圾收集器，那么<code>ParNew收集器</code>则是<code>Serial收集器</code>的<strong>多线程版本</strong>。</p><ul><li><code>ParNew 收集器</code>除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间<strong>几乎没有任何区别</strong>。</li><li><code>ParNew</code> 是很多JVM运行在Server模式下新生代的默认垃圾收集器，因为除了 <code>Serial 收集器</code>，只有它能与<code> CMS 收集器</code>配合工作。</li><li>默认开启的线程数量与 CPU 数量相同，可以使用<code>-XX:ParallelGCThreads</code>参数来设置线程数。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="parnew-old-收集器">ParNew Old 收集器<a class="hash-link" href="#parnew-old-收集器" title="Direct link to heading">​</a></h4><p>是 <code>Parallel Scavenge 收集器</code>的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old 收集器</code>。</p><p><strong>并行串行如何选择？</strong></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="parallel-scavenge-收集器">Parallel Scavenge 收集器<a class="hash-link" href="#parallel-scavenge-收集器" title="Direct link to heading">​</a></h4><p><strong>Parallel Scavenge 收集器：吞吐量优先</strong></p><p>![Parallel Scavenge]<!-- -->(JVM\Parallel Scavenge.png)</p><p>​		<code>Parallel Scavenge 收集器</code>也是多线程收集器，不过和<code>ParNew收集器</code>不同，<code>Parallel Scavenge收集器</code>的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。自适应调节策略也是<code>Parallel Scavenge</code>与<code>ParNew</code>一个重要区别。</p><ul><li>自适应调节：动态调整内存分配情况，以达到一个最优的吞吐量或低延迟。</li><li>吞吐量：CPU用于运行用户代码的时间与CPU总消耗时间的比值，即运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。</li><li><strong>在Java8中，默认是此垃圾收集器。</strong></li></ul><p>​		停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><ul><li>高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，<strong>主要适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</li><li><code>Parallel收集器</code>在JDK1.6时提供了用于执行老年代垃圾收集的<code>Parallel Old收集器</code>，用来代替老年代的<code>Serial Old收集器</code>。</li><li><code>Parallel Old收集器</code>采用了标记-压缩算法，但同样也是基于并行回收和<code>Stop-the-World</code>机制。</li></ul><p>注：可以通过一个开关参数打开 GC 自适应的调节策略(GC Ergonomics)，就不需要手动指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><p><strong><code>Hotspot</code>有这么多的垃圾回收器，那么<code>Serial GC</code>、<code>Parallel GC</code>、<code>Concurrent Mark Sweep GC</code>如何选择呢？</strong></p><ul><li>如果你想要最小化地使用内存和并行开销，请选<code>Serial GC</code>；</li><li>如果你想要最大化应用程序的吞吐量，请选<code>Parallel GC</code>；</li><li>如果你想要最小化GC的中断或停顿时间，请选<code>CMS GC</code>。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="cms-收集器">CMS 收集器<a class="hash-link" href="#cms-收集器" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="CMS" src="/assets/images/CMS-cf14db34e0d5b4e275d4bd9845ca7108.png" width="1176" height="343" class="img_E7b_"></p><p>​		CMS(Concurrent Mark Sweep)收集器，<code>Mark Sweep </code>指的是标记 - 清除算法。</p><p>​		CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段(涉及STW（Stop The World）的阶段主要是：初始标记 和 重新标记)。</p><ul><li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为<code>Stop-the-World</code>机制而出现短暂的暂停，<strong>这个阶段的主要任务仅仅只是标记出<code>GC Roots</code>能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li><li>并发标记（Concurrent-Mark）阶段：从<code>GC Roots</code>的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程</strong>，<strong>可以与垃圾收集线程一起并发运行</strong>。</li><li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，<strong>因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</strong>这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致<code>Stop-the-World</code>的发生，但也远比并发标记阶段的时间短。</li><li>并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。<strong>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</strong></li></ul><p><strong>一些弊端</strong></p><ul><li>吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 <code>Serial Old</code> 来替代<code> CMS</code>。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 <code>Full GC</code>。</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="g1-收集器">G1 收集器<a class="hash-link" href="#g1-收集器" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-text codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">官网：https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/`G1`GettingStarted/index.html</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>​		<strong>为了适应现在不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量，<code>G1</code>就出现了，<code>G1</code>(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。<code>Hotspot</code> 开发团队赋予它的使命是未来可以替换掉 <code>CMS 收集器</code>。</p><p><strong>G1的特点</strong></p><ul><li><p>并行与并发兼备</p><ul><li>并行性：<code>G1</code>在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程<code>STW</code>。</li><li>并发性：<code>G1</code>拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li></ul></li><li><p>分代收集</p><ul><li><p>从分代上看，<code>G1</code>依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有<code>Eden区</code>和<code>Survivor区</code>。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p></li><li><p>将堆空间分为若干个大小相等的独立区域（Region），这些区域中包含了逻辑上的年轻代和老年代，二者不再物理隔离。</p><p><img loading="lazy" alt="G1" src="/assets/images/G1-edc2c453caacf2db2587f8a0e26f87e7.png" width="1208" height="364" class="img_E7b_"></p></li><li><p>和之前的各类回收器不同，它同时兼顾年轻代和老年代。</p></li></ul></li></ul><p>​		内存的回收是以region作为基本单位的。<strong>Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，<code>G1</code>的优势更加明显。</p><p> <strong>常见操作步骤</strong></p><p><code>G1</code>的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ol><li>第一步：开启<code>G1</code>垃圾收集器</li><li>第二步：设置堆的最大内存 <code>-Xmx</code>（起始内存） 和 <code>-Xms</code>（最大内存） </li><li>第三步：设置最大的停顿时间<code>-XX:MaxGCPauseMillis</code></li></ol><p><code>G1</code>中提供了三种垃圾回收模式：<code>YoungGC</code>、<code>Mixed GC</code>和<code>Full GC</code>，在不同的条件下被触发。</p><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 <code>Hotspot</code> VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full  GC）</p><ul><li><p>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为新生代收集（Minor GC/Young GC）和老年代收集（Major GC/Old GC）。</p><ul><li><p>目前，只有 <code>CMS GC</code> 会有单独收集老年代的行为。</p></li><li><p>很多时候 <code>Major GC</code> 会和 <code>Full GC</code>  混合使用，需要具体分辨是老年代回收还是整堆回收。</p></li><li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集，目前只有 <code>G1 GC </code>会有这种行为。</p></li></ul></li><li><p>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="内存分配策略">内存分配策略<a class="hash-link" href="#内存分配策略" title="Direct link to heading">​</a></h3><ul><li><p>对象优先在 <code>Eden</code> 分配</p><ul><li>大多数情况下，对象在新生代 <code>Eden 区</code>分配，当<code> Eden 区</code>空间不够时，发起 <code>Minor GC</code>。</li></ul></li><li><p>大对象直接进入老年代</p><ul><li>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</li><li>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</li><li><code>-XX:PretenureSizeThreshold</code>可以设置临界值，大于此值的对象直接在老年代分配，避免在<code> Eden 区</code>和 <code>Survivor 区</code>之间的大量内存复制。</li></ul></li><li><p>长期存活的对象进入老年代</p><ul><li><code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值。对象在<code>Eden</code>出生并经过<code> Minor GC</code> 依然存活，移动到 <code>Survivor </code>中，年龄就增加 1 岁，增加到临界值则移动到老年代中。</li></ul></li><li><p>动态对象年龄判定</p><ul><li>虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 <code>Survivor </code>空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到<code>MaxTenuringThreshold</code> 中要求的年龄。</li></ul></li><li><p>空间分配担保</p><ul><li><p>在发生 <code>Minor GC</code> 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。</p><ul><li><p>如果条件成立的话，那么 <code>Minor GC</code> 可以确认是安全的。</p></li><li><p>如果不成立，虚拟机会查看 <code>HandlePromotionFailure</code> 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。</p><ul><li>如果大于，将尝试着进行一次 <code>Minor GC</code>；</li><li>如果小于，或者 <code>HandlePromotionFailure</code> 设置不允许冒险，那么就要进行一次 <code>Full GC</code>。</li></ul></li></ul></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="参考资料">参考资料<a class="hash-link" href="#参考资料" title="Direct link to heading">​</a></h2><ul><li><a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1PJ411n7xZ</a></li><li><a href="https://pdai.tech/md/java/jvm/java-jvm-classload.html" target="_blank" rel="noopener noreferrer">https://pdai.tech/md/java/jvm/java-jvm-classload.html</a></li><li><a href="https://blog.xianglin.store/2021/01/17/JVM%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener noreferrer">https://blog.xianglin.store/2021/01/17/JVM%E5%9F%BA%E7%A1%80/</a></li><li><a href="https://pdai.tech/md/java/jvm/java-jvm-struct.html" target="_blank" rel="noopener noreferrer">https://pdai.tech/md/java/jvm/java-jvm-struct.html</a></li><li><a href="https://pdai.tech/md/java/jvm/java-jvm-gc.html" target="_blank" rel="noopener noreferrer">https://pdai.tech/md/java/jvm/java-jvm-gc.html</a></li></ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs-web/常见漏洞类型/文件包含"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">文件包含</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#jvm发展历程" class="table-of-contents__link toc-highlight">JVM发展历程</a></li><li><a href="#类加载子系统" class="table-of-contents__link toc-highlight">类加载子系统</a><ul><li><a href="#类的生命周期" class="table-of-contents__link toc-highlight">类的生命周期</a></li><li><a href="#类加载器" class="table-of-contents__link toc-highlight">类加载器</a></li><li><a href="#jvm类加载机制" class="table-of-contents__link toc-highlight">JVM类加载机制</a></li></ul></li><li><a href="#运行时数据区" class="table-of-contents__link toc-highlight">运行时数据区</a><ul><li><a href="#程序计数器" class="table-of-contents__link toc-highlight">程序计数器</a></li><li><a href="#虚拟机栈" class="table-of-contents__link toc-highlight">虚拟机栈</a></li><li><a href="#本地方法栈" class="table-of-contents__link toc-highlight">本地方法栈</a></li><li><a href="#堆区" class="table-of-contents__link toc-highlight">堆区</a></li><li><a href="#方法区" class="table-of-contents__link toc-highlight">方法区</a></li></ul></li><li><a href="#执行引擎" class="table-of-contents__link toc-highlight">执行引擎</a></li><li><a href="#垃圾回收" class="table-of-contents__link toc-highlight">垃圾回收</a><ul><li><a href="#标记阶段" class="table-of-contents__link toc-highlight">标记阶段</a></li><li><a href="#清除阶段" class="table-of-contents__link toc-highlight">清除阶段</a></li><li><a href="#引用类型" class="table-of-contents__link toc-highlight">引用类型</a></li><li><a href="#垃圾收集器" class="table-of-contents__link toc-highlight">垃圾收集器</a></li><li><a href="#内存分配策略" class="table-of-contents__link toc-highlight">内存分配策略</a></li></ul></li><li><a href="#参考资料" class="table-of-contents__link toc-highlight">参考资料</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">感谢</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://docusaurus.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Docusaurus<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/urdr-gungnir" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gungnir@TnT-Security-Lab<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">了解我们</a></li><li class="footer__item"><a href="https://github.com/TnT-Security-Lab" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站总访问量:<span id="busuanzi_value_site_pv"></span>次</span><br>
        Copyright © 2022 Gungnir@TnT-Security-Lab.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.906e371d.js"></script>
<script src="/assets/js/main.16b6c330.js"></script>
</body>
</html>